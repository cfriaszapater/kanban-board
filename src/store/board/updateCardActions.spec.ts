import expect from "expect";
import configureMockStore, { MockStore } from "redux-mock-store";
import thunk from "redux-thunk";
import { givenKanbanBoardStateWithSomeCards } from "../../../testUtil/givenStateWithSomeCards";
import { backendUrl } from "../../util/backendUrl";
import { CardsActionsTypes } from "./CardsActionsTypes";
import { Card, CardLoaded } from "./types";
import {
  BEGIN_TASK_EDITING,
  beginCardEditing,
  CHANGE_TASK_EDITING,
  changeCardEditing,
  DELETE_CARD_BEGIN,
  deleteCard,
  UPDATE_CARD_BEGIN,
  UPDATE_CARD_SUCCESS,
  updateCard,
  UpdateCardActions,
  updateCardBegin,
  UpdateCardBeginAction
} from "./updateCardActions";

const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);

describe("card editing actions", () => {
  let store: MockStore;

  beforeEach(() => {
    fetchMock.resetMocks();
    store = mockStore();
  });

  it("should dispatch action on start editing", () => {
    const card = { id: "13", content: "hi" };

    const action = store.dispatch(beginCardEditing(card));

    expect(action).toEqual({
      card,
      editing: true,
      type: BEGIN_TASK_EDITING
    });
  });

  it("should dispatch action on change editing", () => {
    const card = { id: "13", content: "hi" };

    const newContent = "jarl";
    const action = store.dispatch(changeCardEditing(card, newContent));

    expect(action).toEqual({
      card,
      newContent,
      type: CHANGE_TASK_EDITING
    });
  });

  it("should dispatch UPDATE_CARD_BEGIN for card with new content and not editing", () => {
    const card: CardLoaded = {
      _id: "backend-generated-id-jarl",
      content: "hi",
      editing: true,
      id: "13",
      loading: false
    };

    const newContent = "jarl";
    const action = store.dispatch(updateCardBegin(card, newContent));

    const cardWithNewContentNotEditing: Card = {
      ...card,
      content: newContent,
      editing: false
    };
    const expectedAction: UpdateCardBeginAction = {
      card: cardWithNewContentNotEditing,
      type: UPDATE_CARD_BEGIN
    };
    expect(action).toEqual(expectedAction);
  });

  it("should BEGIN, fetch and SUCCESS on update card", () => {
    const card: CardLoaded = {
      _id: "autogenerated-backend-id-grmblf",
      content: "Do the laundry",
      id: "card-13",
      loading: false
    };
    fetchMock.once(JSON.stringify({ json: card }));

    const newContent = "new content";
    const cardWithNewContentNotEditing: Card = {
      ...card,
      content: newContent,
      editing: false
    };
    return store
      .dispatch(updateCard(card, newContent) as any)
      .then(expectations());

    function expectations(): any {
      return () => {
        const expectedActions: UpdateCardActions[] = [
          { type: UPDATE_CARD_BEGIN, card: cardWithNewContentNotEditing },
          { type: UPDATE_CARD_SUCCESS, card: cardWithNewContentNotEditing }
        ];
        expect(store.getActions()).toEqual(expectedActions);
        expect(fetchMock.mock.calls.length).toEqual(1);
        expect(fetchMock.mock.calls[0][0].url).toEqual(
          backendUrl() + "/cards/" + card._id
        );
      };
    }
  });

  it("given column with cards, when delete card, then BEGIN and DELETE /cards and PUT /columns", () => {
    fetchMock.mockResponses("", "");
    const givenState = givenKanbanBoardStateWithSomeCards();
    store = mockStore(givenState);
    const card1 = givenState.cards[Object.keys(givenState.cards)[0]];

    return store.dispatch(deleteCard(card1) as any).then(expectations());

    function expectations(): any {
      return () => {
        // Nothing to do in UI on SUCCESS, then no SUCCESS action dispatched
        const expectedActions: CardsActionsTypes[] = [
          {
            card: card1,
            type: DELETE_CARD_BEGIN
          }
        ];
        expect(store.getActions()).toEqual(expectedActions);

        expect(fetchMock.mock.calls.length).toEqual(1);
        expect(fetchMock.mock.calls[0][0].url).toEqual(
          backendUrl() + "/cards/" + card1._id
        );
        expect(fetchMock.mock.calls[0][0].method).toEqual("DELETE");
      };
    }
  });
});
